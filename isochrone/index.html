<!DOCTYPE html>
<html>
<head>
  <title>Isochrones</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://npmcdn.com/leaflet@1.0.0-rc.2/dist/leaflet.css" />
</head>
<body>
  <div id="map" style="width: 1440px; height: 810px"></div>
  <script src="https://npmcdn.com/leaflet@1.0.0-rc.2/dist/leaflet.js"></script>
  <script src="https://code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script>
    //make a map
    var map = L.map('map').setView([37.8, -122.4], 13);
    var geojson = null;

    //use osm tiles
    L.tileLayer('http://b.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 18,
      attribution: '&copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributers'
    }).addTo(map);
    
    //click callback
    function onMapClick(e) {
      //build url
      var url = 'https://valhalla.dev.mapzen.com/isochrone?api_key=valhalla-t_16n1c&json=';
      var json = {
        locations: [{"lat":e.latlng.lat, "lon":e.latlng.lng}],
        costing: "multimodal",
        contours: [{"time":15},{"time":30},{"time":45},{"time":60}],
        rings_only: true,
        denoise: .1
      };
      url += escape(JSON.stringify(json));
      //grab the url
      $.getJSON(url,function(isochrones){
        //clear this if its not null
        if(geojson != null)
          geojson.removeFrom(map);

        //for each feature compute an axis aligned bounding box
        var features = isochrones.features;
        var bboxes = [];
        features.forEach(function(feature) {
          var box = [feature.geometry.coordinates[0][0].slice(), feature.geometry.coordinates[0][0].slice()];
          feature.geometry.coordinates.forEach(function(ring) {
            ring.forEach(function(point) {
              //min
              if(point[0] < box[0][0])
                box[0][0] = point[0];
              if(point[1] < box[0][1])
                box[0][1] = point[1];
              //max
              if(point[0] > box[1][0])
                box[1][0] = point[0];
              if(point[1] > box[1][1])
                box[1][1] = point[1];
            });
          });
          bboxes.push(box);
        });

        //test whether the inner bbox lies within the outer
        var inside = function(outer, inner) {
          return inner[0][0] >= outer[0][0] && inner[1][0] <= outer[1][0] &&
                 inner[0][1] >= outer[0][1] && inner[1][1] <= outer[1][1];
        };

        //for each feature in reverse
        for(var i = features.length - 1; i > 0; i--) {
          //make sure we are on the next contour
          var j = i - 1;
          while(j >= 0 && features[i].properties.contour == features[j].properties.contour)
            j--;
          if(j < 0)
            break;
          //find the first one that fits in this contour
          var contour = features[j].properties.contour;
          while(j >= 0 && features[j].properties.contour == contour) {
            //does it fit as an inner ring this will make a cut out
            //reversing the winding of this inner is more proper
            //but it seems this renderer doesnt care at all
            if(inside(bboxes[j], bboxes[i])) {
              features[i].geometry.coordinates.forEach(function (p) { features[j].geometry.coordinates.push(p); });
              break;
            }
            j--;
          }
        }


for(var i = 0; i < features.length; i++){
if(features[i].properties.contour != 30) {
features.splice(i, 1);
}
}  

        //create the geojson object
        geojson = L.geoJson(isochrones, { style: function(feature) { 
          return { fillColor: feature.properties.fill,
                   fillOpacity: feature.properties["fill-opacity"],
                   weight: 1,
                   color: '#FFFFFF'
                 };
        }});
        //render the geojson
        geojson.addTo(map);
      })
    }
    
    //hook up the callback
    map.on('click', onMapClick);
  </script>
</body>
</html>
